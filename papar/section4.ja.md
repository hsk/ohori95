# 多相レコード計算とそのコンパイル

  大堀あつし
  
  京都大学

  この作業の目的は、ラベル付きレコードとラベル付きバリアントを使用した実用的な多形プログラミング言語を開発するための型理論的基礎を提供することです。
  私たちの目標は、それらのラベル付きデータ構造を持つ計算型の規律と、計算のための効率的なコンパイル方法の両方を確立することです。
  Girard-Reynolds多相ラムダ計算の拡張として、二階多相レコード計算を定義します。
  次に、二階レコード計算の予測サブセットのためのML型型推論アルゴリズムを開発します。
  タイプシステムの健全性とタイプ推論アルゴリズムの完全性が示されています。
  これらの結果は、Milnerの型推論アルゴリズム、DamasとMilnerのMLの多相を説明し、HarperとMitchellのXML解析を拡張します。
  多相レコード計算のための効率的なコンパイル方法を確立するために、まず、実装計算を定義します。ここで、レコードは、直接索引付けによって要素にアクセスするベクターとして表され、バリアントは、スイッチステートメント内の関数のベクター内の位置を示す自然数でタグ付けされた値として表されます。
  次に、型推論アルゴリズムによって得られた型情報を用いて、多相レコード計算を実装計算に変換するアルゴリズムを開発します。
  コンパイルアルゴリズムの正確性が証明されています。つまり、コンパイルアルゴリズムは、プログラムの入力と操作の両方の動作を保持するために示されています。
  これらの結果に基づいて、Standard ML はラベル付きレコードで拡張され、コンパイラが実装されました。

  カテゴリーとサブジェクト記述子: D.3.1 [プログラミング言語]: 正式な定義と理論; D.3.2 [プログラミング言語]: 言語分類 - 適用言語; D.3.3 [プログラミング言語]: 言語構成と特徴 - データ型と構造

  一般条件: 言語

  追加キーワードとフレーズ: コンパイル、多相、レコード計算、型推論、型理論

  ----

  この記事の結果の一部の予備的な要約は、「MLスタイル多形レコード計算のためのコンパイル方法」のタイトルの下、1992年のACMシンポジウムのプログラミング言語原則に関する講演集に掲載されました。

  この研究は、科学研究費補助金の下、日本教育省によって部分的に支持された。 06680319。

  著者所在地: 京都大学数理科学研究所、京都大学、京都府京都市、 email: ohori@kurims.kyoto-u.ac.jp

  この資料の全部または一部を無償でコピーすることが許可されるのは、コピーが直接的な商業的利益のために作成または配布されていない場合、ACMの著作権表示とその題名と日付が表示され、コピーがACMの許可。
  そうでなければコピーするか、または再発行するには、料金および/または特定の許可が必要です。

  c 1999 ACM 0164-0925/99/0100-0111 $00.75

  ----

# 1. はじめに

  ラベル付きレコードおよびラベル付きバリアントは、広く使用されているデータ構造であり、データベースプログラミングなどのさまざまなデータ集約型アプリケーションの不可欠なビルディングブロックです。
  しかし、実際の重要性にもかかわらず、既存の多形プログラミング言語はこれらのデータ構造を適切にサポートしていません。
  Standard ML [Milner et al. 1990] には、ラベル付きレコードとラベル付きバリアントの形式が含まれていますが、許容される操作は単形性のものに限定されています。
  たとえば、レコードの次の単純な関数名を考えてみましょう。

  <!--2-->

    name ≡ λx.x#Name

  x#Name は、レコードxから名前フィールドを選択するための構文です。
  この関数は、 {Name : string, Age : int} や {Name : string, Office : int} などのNameフィールドを含むレコードタイプの用語に適用できるという意味で多相性です。
  この関数をMLに書き込む方法の1つは、

    fun name(x) = #Name x

  ここで、 #Name は λx.x#Name の ML の構文です。
  このプログラムは、次のように、プログラマが明示的にxの型を指定しない限り、現在のMLコンパイラによって拒否されます。

    fun name(x:{Name:string, Age:int}) = #Name x

  残念なことに、このような型指定を書くことは面倒であるだけでなく、上記のようなレコードで動作する関数の柔軟性の大部分を排除します。
  ラベルされた変異体には類似の状況が存在します。
  異なる型の値を一様に扱いたい場合は、 variant 型 (disjoint union型) を使用します。
  単純なディスジョイント・ユニオン型よりもラベル付きバリアントの大きな利点は、シンボリック・ラベルによって値の種類を指定することにより柔軟なプログラミングをサポートすることです。
  たとえば、以下のように定義されたバリアントバリューの支払いを考えてみましょう。

    payment ≡ <Pound=100.0>

  ここで、値100.0はバリアントラベルPoundでタグ付けされています。
  支払いは、<Pound : real, Dollar : real> または <Pound : real, Yen : int>、または Pound : real フィールドを含む他のバリアントタイプなど、さまざまな異なるバリアントタイプの値として扱うことができます。
  残念なことに、この形式の柔軟なプログラミングは、変種の値を単形性に制限するため、既存の多相型言語では利用できません。
  たとえば、 Standard ML では、バリアントタイプは以下のように定義されます。

    datatype PoundOrYen = Pound of real | Yen of int

  しかし、この定義は、PoundとYenのバリアントラベルをこの特定の型PoundOrYenに結びつけます。
  したがって、このタイプに対して支払などの値が定義されている場合、他のバリアントタイプの値として使用することはできません。
  Standard ML プログラミングでは、この問題を回避するために一般的に採用されているアドホック戦略は、すべての可能なコンポーネントを含むバリアント型を定義し、バリアント値を操作する際のいくつかのケースを省略することです。
  しかし、このアプローチでは、コンパイル時に捕捉されるべきであった型エラーである "マッチ失敗"のランタイム例外が導入されています。

  多相プログラミング言語を拡張して、ラベル付きレコードおよびラベル付きバリアントの多型操作を可能にすることが非常に望ましい。
  この記事では、ラベルされたレコードとラベル付きバリアントの多型操作に必要な多形の形式を参照するために、レコード多形という用語を使用します。
  私たちの目標は、記録多型をサポートする多形プログラミング言語を開発するための基礎を提供することです。
  この目標を達成するには2つの技術的課題があります。
  第1は、記録多型を表すことができる静的型システムの開発です。
  2つ目は、レコードとバリアントの多相演算の効率的なコンパイル方法の開発です。
  この記事では、この2つの問題の解決方法を示します。
  このセクションの残りの部分では、この記事で説明した問題点と解決方法の概要を説明します。
  この記事の一部は、優雅な抽象化と型推論に基づく編集の予備的なプレゼンテーションに基づいています[Ohori 1992]。

  <!--3-->

# 1.1 多相レコードのための静的型システム

  レコード多相性は、ラベル付きフィールドアクセスが多相的であるため、指定されたフィールドを含むラベル付きデータ構造体に適用できるという性質に基づいています。
  たとえば、レコードの `Name` フィールドにアクセスする関数名と `case` 文の `Pound` ブランチにアクセスする値 `payment` には、すべての型のフォームがあります。

    name : {Name:τ,···}→τ,
    payment : <Pound:real,···>

  しかしながら、従来の多相型システムは、それらの形状のすべての可能な型の集合を表すことができず、したがって、それらの項を含むプログラムの多相性を表すことはできません。

  Cardelli [1988]は、この多相型の形式は、サブ型の関係を定義し、その値がすべてのスーパー型を持つことを可能にすることによって捕捉できることを観察しました。
  このアプローチはまた、メソッド継承の特定の側面をサポートし、オブジェクト指向プログラミングのための型理論的基礎を提供します。
  Cardelli and Wegner [1985] はこのアプローチを2階型システムに拡張します。
  サブ型を持つ型推論システムも開発されています [Fuh and Mishra 1988; Mitchell 1984; Stansifer 1988]。
  しかし、レコード多相型のメカニズムとサブ型の強力なメカニズムが組み合わされるべきかどうかは不明です。
  サブ型が存在する場合、静的型はもはや実行時の値の正確なレコード構造を表しません。
  例えば、項

    if true then {A = 1, B = true} else {B=false, C=”Cat”}

  は型 `{B:bool}` を持ちますが、実行時の値はおそらく `{A=1,B=true}` になります。
  このプロパティは、値の正確な構造に依存する等価性テストなどの操作に対処する場合に問題になることがあります。
  セクション6で議論するように、サブ型も実装を複雑にします。
  Wand [1987; 1988] によって始められた別のアプローチは、多相レコードのために直接 ML 型多相型付けを拡張することです。 この考え方は、いくつかの型推論システムでさらに発展しました [Jategaonkar and Mitchell 1993; Ohori and Buneman 1988; 1989; Rémy1989; 1992; 1994b; Wand 1989]。

  これらの型システムでは、最も一般的な多相型スキームは、レコード上の操作を含む型指定可能な型なし項に対して推論できます。
  推論された型スキームの適切なインスタンス化によって、型なしの項はさまざまな異なる型の値として安全に使用できます。
  このアプローチは、レコードの関数の多相性をキャプチャするだけでなく、レコード多相性とMLスタイルの型推論を統合し、プログラマが明示的な2階計算に必要な複雑な型宣言を書くことを軽減します。

  提案された型推論システムの大部分は、有限集合のフィールド型に及ぶ変数である行変数[Wand 1987]のメカニズムに基づいています。

  図1 推論型のプログラムの例

  ここでは、 row 変数を使用する代わりに、 Ohori と Buneman [1988] が提示した考え方に基づいて、型変数のインスタンス化の可能性を制限する方法を開発します。
  この考え方を型の類型体系として定式化し、通常の型の定量化を、 `t::k.σ` 型の類型化された量化に改良します。ここで、型変数 `t` は、kind `k` によって示される型の集合にわたってのみ範囲が限定されます。
  このメカニズムは有界量化 [Cardelli and Wegner 1985] に類似しています。
  kind `k` は、全ての型の集合を表すユニバーサル kind `U`、 全レコード型の集合を示す形式 `{{l1:τ1,···,tn:τn}}` の kind、または指定されたフィールドを含むすべてのバリアント型の集合を表す `<<l1:τ1,···,tn:τn>>` の形式のバリアント型を返します。

  このメカニズムにより、我々は様々なレコード操作の多相性を表現することができます。
  たとえば、関数 `name` と `payment` には、次の型があります:

    name : ∀t1::U.∀t2::{{Name:t1}}.t2→t1
    payment : ∀t::<<Pound : real>>.t

  `name` は `Name:t1` フィールドを含む任意のレコード型の値をとり、 `t1` 型の値を返す関数であり、`t1` は任意の型であり、 `payment` は任意の型を持つ多相型の値であることを示し、 `Pound:real` コンポーネントを含むバリアント型です。
  このメカニズムにより、これらの項は多相的に使用することができます。
  ラベル付きフィールドアクセスに加えて、kinded抽象化は `e1`からの新しいレコードを作成する `modify(e1,l,e2)` の多相レコード変更 (update) 他のすべてのフィールドは変更されません。
  次の型指定は、この構造の多相性を示しています。

    λx.λy.modify(y,l,x) : ∀t1::U.∀t2::{{l:t1}}.t1→t2→t2

  これらの機能を組み合わせることで、スタティック型の利点と、ML型の完全な型推論アルゴリズムの存在を犠牲にすることなく、柔軟なプログラミングが可能になります。
  図1は、ML形式の多相関数宣言を使用して、ラベル付きレコードおよびバリアントに関する型付けの例を示しています。

  この形式のプログラミングは、前述の row 変数に基づくML形式の多相レコード計算の他の提案でも可能です。
  我々の定式化の1つの利点は、明示的に型付けされた計算とML型の型推論システムの両方に対して一様な処理をもたらすことです。
  型推論アルゴリズムのほとんどは2階の型なしで定義され todo、MLのletバインディングを明示的に扱いません。
  Rémy[1994b]は形式的にMLの束縛を扱います。
  しかし、明示的に型付けされた2階のシステムとの関係は、十分に調査されていません。
  優雅な抽象を用いて、Girard [1971]とReynolds [1974]の2階ラムダ計算を拡張して2階ラムダ計算の基本特性を保存することを示します。
  次に、2階ラムダ計算の述語サブセットのためのML型型推論システムを開発します。
  これらの結果は、Damner と Milner [1982] による ML let 多相の型システムである Milner [1978] の型推論アルゴリズムと、 ML 多相と Harper と Mitchell によるpredicative二階システム[1993] です。
  これらの接続は、多相レコードのために多相型規律の様々な既知の結果を転送することを可能にします。

  しかし、 row 変数は、レコードに対する様々な強力な操作を表現するのに適しているように見えることに注意してください。
  row 変数に基づく型システムの中で、最も柔軟性の高いものは Rémy[1994b] のものであり、 row 変数にソートされた等式理論を使用しています。
  多相レコードフィールドへのアクセス、レコードの変更、および多相のために、彼の型システムは我々と同等の多相性を提供します。
  たとえば、関数名には、自分のシステムで次のような型指定が与えられます。

    λx.x#Name : (ρ {Name} ; Name : pre(t)) → t

  ここで、 `ρ{Name}` は `Name` フィールドを含まない可能な row (レコードフィールドの有限集合) を表すソートされた row 変数で、`pre(t)` は型 `t` の `Name` フィールドの存在を示します。
  この型付けは、2つが同じ基礎インスタンスの集合を表すという意味で、私たちの計算における型付けと同じです。
  しかし、彼のシステムは、新しいフィールドでレコードを拡張する操作と、既存のフィールドをレコードから削除する操作を表すことができ、我々の型システムでは表現できないという点で、より強力です。
  レコード拡張操作の制限された形式は Jategaonkar と Mitchell [1993] でサポートされています。
  拡張可能なレコードの明示的に型付けされた2階計算も提案されています [Cardelli and Mitchell 1989; Harper and Pierce 1991]。
  これらの拡張操作が利用できないということは、我々の型システムの限界です。
  しかし、row 変数に基づくレコード計算は、コンパイルするのが難しいようです。
  著者の知る限り、これらのレコード計算のいずれに対しても、体系的なコンパイル方法は知られていません。
  型システムの重要な利点は、次のサブセクションで説明するように、ラベル付きフィールドアクセスを直接インデックス操作にコンパイルする効率的なコンパイル手法を開発できるということです。

# 1.2 レコード多相型のコンパイル方法

  レコード多相型を用いた実用的なプログラミング言語を開発する上での2番目の技術課題はコンパイル手法です。
  ラベル付けされたレコードの重要な特性は、位置情報ではなく、ラベル、すなわち記号名によるレコードの要素にアクセスする能力です。
  静的に型付けされた単形言語では、これはコンパイルに何の問題も生じません。
  各ラベル付きフィールドの実際の位置はレコードの型から静的に決定されるため、ラベル付きフィールドアクセスは通常、単一の機械命令によって実装されるインデックス操作に簡単にコンパイルされます。
  しかし、レコード多相型を持つ言語では、コンパイルは難しい問題です。
  関数 `λx.x#Name` をもう一度考えてみましょう。
  実際の引数は名前フィールドの位置が異なるため、この関数をインデックス操作を実行する関数にコンパイルすることは不可能です。

  1つの直接的なアプローチは、すべての可能なラベルのオフセットを事前に決定し、空きスロットが多い可能性のある非常に大きな構造としてレコードを表現することです。
  Cardelli [1994]は、サブタイピングの純粋計算でレコードを表現するこの戦略をとりました。
  このアプローチは、レコード多相型の正式な特性を研究するのに有用であるが、実際には非現実的です。
  別の単純なアプローチは、ラベルと値の関連リストとして表されるレコード内の指定されたラベルを動的に検索することによって、ラベル付きフィールドアクセスの意図されたセマンティクスを直接実装することです。
  このようなアプローチの明らかな欠点は、ランタイム実行の非効率性です。
  フィールドアクセスは頻繁に呼び出される基本的な操作であるため、このような方法は深刻なアプリケーション開発には受け入れられません。

  ダイナミックフィールドルックアップのより現実的なアプローチは、ハッシングの形式を使用することです。
  Rémy[1994a]は、拡張可能なハッシングに類似したハッシングの形式を使用する、効率的で動的なフィールドルックアップ方法を提示し[Fagin et al。 1979]、フィールド選択は、実行時間と余分なメモリ使用量の両方において比較的短いランタイムオーバーヘッドで実施できることを示しました。
  これは、ラベル付きフィールドの位置の静的な決定が不可能な様々なレコード計算のための妥当な実装技術となり得ます。
  この方法の欠点は、プログラムが完全に単相性であっても、ラベルフィールドアクセスが常に余分なランタイムオーバヘッドを招くため、ラベルの位置を静的に決定できないことです。
  多相型システムでより高度な言語に移行する際に、単相ラベルフィールドアクセスのために特別なペナルティを課さなければならないのは残念です。
  ハッシュのもう1つの欠点は、任意のレコードに対して動作する保証がないことです。
  たとえば、Remyのテクニックは、50または100フィールドの大きなレコードの場合はうまく機能しません。

  <!--7-->

  多相レコード計算が実用的なプログラミング言語の基礎となるためには、レコード表現のコンパクト性とラベル付きフィールドアクセスの実行効率の両方を常に達成するコンパイル方法を開発する必要があります。
  Connor et al. [1989]は、サブタイピングを伴う明示的に型付けされた言語の文脈でこの問題を考慮し、実装戦略を提案しました。
  しかし、彼らは任意の表現に対処するための体系的な方法を提供しておらず、型推論システムも考慮していませんでした。
  この記事の第2の目的は、このようなコンパイル方法を開発し、そのコンパイルが多相レコード計算の意図された動作上の動作を達成することを確認することです。

  私たちの戦略は、多相レコード計算を実装計算に変換することです。
  実装計算では、ラベル付きレコードは、ラベル集合の正則順序によって順序付けられた値のベクトルとして表され、フィールドは直接インデックスによってアクセスされます。
  バリアント値は、switch文の関数ベクトル内の位置を示す自然数でタグ付けされた値として表されます。
  多相フィールドの選択と多相バリアントに対処するために、実装計算にはインデックス変数とインデックス抽象化が含まれています。
  たとえば、型なし項

    let name = λx.x#Name in (name {Name=”Joe”, Office=403},
                             name {Name=”Hanako”, Age=21, Phone=7222})

  から変換アルゴリズムは次の実装コードを生成します:

    let name = λIλx.x[I] in ((name 1) {”Joe”,403}, (name 2) {21,”Hanako”,7222})

  ここで、 I はインデックス変数です;
  λI. M は索引抽象です;
  x[I] はインデックス式です;
  {"Joe",403} および {21, "Hanako", 7222} は、フィールドがラベル上の辞書順に並べられたレコードのベクトル表現です。
  (name 1) と (name 2) は、インデックス変数 I に適切なインデックス値を供給するインデックス関数適用です。
  同様に、型なし項

    let payment = <Pound=100.0>
    in (case payment of <Pound=λx.x, Dollar=λx.x * 0.68>,
        case payment of <Pound=λx.real to int(x * 150.0), Yen = λx.x>)

  は実装計算の次のコードに変換されます:

    let payment = λI.<I=100.0>
    in (switch (payment 2) of <λx.x * 0.68, λx.x>,
        switch (payment 1) of <λx.real to int(x * 150.0), λx.x>)

  多相バリアント payment は、インデックス関数適用 — (payment 1), (payment 2) — を介して供給されるインデックス抽象化を含む項として表され、要素を含む switch 文中の対応する関数を関数ベクトルで選択するために使用されるバリアントラベルの辞書順にソートされます。

  私たちのコンパイル方法は、任意のレコードとバリアントに対して機能し、単体プログラムのランタイムオーバーヘッドは導入しません。
  多相レコード関数およびバリアントの場合、インデックス値を適用する前にインデックス値を渡すために、追加の関数適用が必要です。
  しかし、次のような開発で示すように、多相の項がインスタンス化されている場合にのみ、追加のインデックス関数適用が実行されます。
  だから私たちは、その費用は無視できると考えています。

  <!--8-->

  Connor et al. [1989] では、インデックス値を渡すという一般的な考え方が提案されました。
  私たちの元々の貢献の1つは、（1）多相レコード計算の任意の型の正しい正しい項のための正しい実装項を常に構築する体系的コンパイルアルゴリズムを確立すること、（2）正当性を形式的に確立することです。

# 2 Λ∀,#

    M ::= x | cb | λx:σ.M | M M | λt::k.M | M σ
        | {l=M,···,l=M} | M#l | modify(M,l,M)
        | (<l=M>:σ) | case M of <l=M,···,l=M>

# 3.1 An ML-Style Polymorphic Record Calculus : λlet,#

    e ::= x | cb | λx.e | e e | let x=e in e
        | {l=e,···,l=e} | e#l | modify(e,l,e)
        | <l=e> | case e of <l=e,···,l=e>

    τ ::= t | b | τ→τ | {l:τ,···,l:τ} | <l:τ,···,l:τ>
    σ ::= τ | ∀t::k.σ
    k ::= U | {{l:τ,···,l:τ}} | <<l:τ,···,l:τ>>

# 3.3 Explicitly Typed Calculus Λlet,# Corresponding to λlet,#

  Λlet,# はmssでλlet,#はtyped mss tmssとよぼう

    M ::= (x τ···τ) 具体化
        | cb
        | λx:τ.M
        | M M
        | Poly(M:σ) 一般化
        | let x:σ = M in M
        | {l=M,···,l=M} | M:τ#l | modify(M:τ,l,M)
        | (<l=M>:τ) | case M of <l=M,···,l=M>

  Syntax

<!--27 868-->

# 4. コンパイル

  この章では、 ML スタイルの多相レコード計算 `λlet,#` を以下に定義された実装計算 `λlet,[]` にコンパイルするアルゴリズムを開発します。

<!--26 869-->

    V ::= cb | λx.C | {V,···,V} | <Ï=V> | λI.C' (for some C' such that C'↓C').

    EV[] ::= [·] | EV[] C | V EV[] | let x=EV[] in C | {V,···,V,EV[],···} | EV[][Ï]
           | modify(EV[],I,C) | modify(V,Ï,EV[]) | <Ï=EV[]> | switch EV[] of C,···,C
           | EV[] Ï | λI.EV[]

    EV[(λx.C) V]                                 ⟶ EV[[V/x]C]
    EV[{V1,···,Vn}[i]]                           ⟶ EV[Vi]
    EV[modify({V1,···,Vi−1,Vi,Vi+1,···,Vn},i,V)] ⟶ EV[{V1,···,Vi−1,V,Vi+1,···,Vn}]
    EV[switch <i=V> of C1,···,Cn]                ⟶ EV[Ci V]
    EV[(λI.C') Ï]                                ⟶ EV[[Ï/I]C] if C'↓C'
    EV[let x=V in C]                             ⟶ EV[[V/x]C]

  図12. λlet,[] の値渡し評価の操作的意味論

## 4.1 実装計算: λlet,[]

  我々は、直接インデックス付け可能なベクターと整数タグの `switch` 文を使用して実装計算を定義し、多相レコード計算の効率的な抽象マシンとして定義します。

  後述するように、インデックス値は、後で定義するコンパイルアルゴリズムによって常に静的に計算され、ファーストクラスの値として扱う必要はありません。
  そこで、次の新しいインデックスのカテゴリ (`Ï` の範囲) を導入し、それらを特別に扱います:

    Ï ::= I | i
    ここで、
      I は与えられたインデックス変数の集合を表し、
      i は自然数を表します。

  λlet,[] (`C` の範囲) の raw 項の集合は次の構文で与えられます:

    C ::= x | c b |λx.C | C C | let x=C in C | {C,···,C} | C[Ï]
        | modify(C,Ï,C) | <Ï=C> | switch C of C,···,C | λI.C | C Ï
    ここで
      {C1,···,Cn} はレコードのベクター表現です。
      C[Ï] はベクター C からインデックス値 Ï の要素を検索するインデックス式、
      switch C of C1,···,Cn は、バリアント C の整数タグを解析し、
                               対応する関数 Ci を C の値に適用します。
      λI.C はインデックス抽象で; そして
      C Ï はインデックス関数適用です。

  `λlet,#` のように、 call-by-value の操作的意味は、評価コンテキスト(`EV[]` の範囲)、値の集合(`V` の範囲)、および call-by-value コンテキスト書き換え `EV[C1]−→EV[C2]` の形式の公理を用いて定義されます。
  `C = EV[C1]1`、`EV[C1]1 -EV→EV[C2]1` となるような `EV[]1`、`C1`、`C2`が存在するならば、我々は１ステップで `C` は `C'` に評価されるといい、`C −EV→ C'`と書きます。
  我々は、 `-EV→` の反射的推移的閉包について `-EV→→` と書き; `C -EV→→C'` ならば `C↓C'` かつ `C' -EV→C''` で `C''` は現れません; いくつかの `C'` に対して `C↓C'` ならば `C↓` と書きます。
  図12は、値の集合、 call-by-value の評価コンテキスト、および λlet,[] のコンテキスト書き換え公理の集合の相互再帰的定義を与えます。

<!--27 870-->

## 4.2 λlet,[] の型システム

  次の節で定義されたコンパイルアルゴリズムの正当性を確立するために、実装計算の型システムを定義します。

  実装計算でラベル付けされたレコードとラベル付きバリアントを表すために、ラベルの集合の全体の順序 `<<` を仮定し、レコード型 `{l1:τ1,···,ln:τn}` またはそのバリアント型 `<l1:τ1,···,ln:τn>` は `l1<<···<<ln` の条件を満たす必要があります。
  `<<` の通常の選択は、ラベルの文字列表現における辞書順です。
  `τ` が上記の形式のいずれかである場合、`τ` のラベル `li` のインデックスを `i` と定義します。
  上記レコード型のレコード項は、 `i` 番目の要素が `li` フィールドであるベクターです。
  上記のバリアント型の `li` バリアントは、 `j` 番目の要素が `lj` 変形の関数に対応する関数のベクターを含む `switch` 文によって操作される整数 `i` でタグ付けされた値です。
  たとえば、レコード型が `int` 型の `Age` フィールドと `string` 型の `Name` フィールドで構成されている場合は、`{Age:int,Name:string}` の形式である必要があります。したがって、このレコード型の `Name` のインデックスは `2` です。
  この型の可能な項は、 λlet,# の `{Name="Joe",Age=21}` に対応する `{21,"Joe"}` を含みます。
  同様に、実数型の `Dollar` と実数型の `Pound` のバリアント型は、 `<Dollar:real,Pound:real>` の形式でなければなりません。したがって、型の `Pound` のインデックスは `2` です。
  この型の `switch` 文は、`Dollar` と `Pound` の関数のベクターからこの順番で構成され、この型の `100.0` の `Pound` バリアントは `<2=100.0>` と表され、これは、λlet,＃ における上記型の `<Pound=100.0>` の (単相) 項に対応します。

  多相演算を説明するために、インデックス値に対して新しい形式の `idx(l,τ)` を導入します。
  `τ` がレコード型またはバリアント型の場合、この型は `τ` の `l` のインデックスを示します。
  我々は `idx(l,τ)` で示されるインデックス値に対して `|idx(l,τ)|` と書きます。
  たとえば、`|idx(Name,{Age:int,Name:string})| = 2` です。
  `τ` が型変数 `t` であるとき、 `idx(l,t)` は、 `t` のインスタンス化に応じて可能なインデックス値を示し、 `|idx(l,t)|` 定義されていません。

  実装計算の型の集合は、次の構文で与えられます。

    τ ::= t | cb | τ→τ | {l:τ,···,l:τ} | <l:τ,···,l:τ> | idx(l,τ) ⇒ τ
    σ ::= τ | ∀t::k.σ

  ここで、 `idx(l,τ1)⇒τ2` は、 `idx(l,τ1)` で表されるインデックス値を取り、 `τ2` 型の値を生成する関数を示します。
  インデックス値はファーストクラスのオブジェクトではないので、別々の型としてインデックス型 `idx(l,τ)` を含める必要はありません。
  kind の集合と kinding 規則は λlet,# と同じです。

  この計算の型システムは、以下の形式の判断のための証明システムとして定義されています。

    K,L,T ▷ C : τ       typing judgment
    L |- I : idx(l,τ)    index judgment

  ここで、 `K` は kind 割り当てであり、 `T` は前の計算での型割り当てです。
  `L` はインデックス割り当てであり、インデックス変数のセットから `idx(l,τ)` という形式のインデックス型へのマッピングです。
  `FTV(τ) ⊆ dom(K)` の場合、 `τ,τ'` に現れるすべての型の `idx(l,τ')` に対して、 レコード kind または `K` の下で `l` フィールドを含むバリアント kind を持つならば、型 `τ` は `K` の下で well formed です.
  `τ` が `K{t1::k1···tn::kn}` の下で well formed ならば、型 `∀t1::k1···tn::kn.τ` は `K` の下で　well formed です。
  `L` 内の各型が `K` 下で well formed ならば、 `L` は `K` の下で well formed です。
  `T` 内の各型が `K` の下で well formed ならば、型割り当て `T` は `K` の下で well formed です。

<!--28 871-->

  Syntax

    K,L,T ▷ C : τ       typing judgment
    L ⊢ Ï : idx(l,τ)   index judgment

    IVAR      L{I:idx(l,τ)} ⊢ I : idx(l,τ)
    ICONST1   L ⊢ i : idx(li,{l1:τ1,···,ln:τn})    1 ≤ i ≤ n
    ICONST2   L ⊢ i : idx(li,<l1:τ1,···,ln:τn>)    1 ≤ i ≤ n

    VAR       K,L,T{x:σ} ▷ x : τ      if T{x:σ} and L are well formed under K and K ⊢ σ ≥ τ
    CONST     K,L,T ▷ cb : b          if T and L are well formed under K

              K,L,T ▷ C1 : τ1→τ2    K,L,T ▷ C2 : τ1
    APP       ----------------------------------------
              K,L,T ▷ C1 C2 : τ2

              K,L,T{x:τ1} ▷ C1 : τ2
    ABS       -----------------------
              K,L,T ▷ λx.C1 : τ1→τ2

              K,L{I:idx(l,τ1)},T ▷ C1 : τ2
    IABS      --------------------------------
              K,L,T ▷ λI.C1 : idx(l,τ1) ⇒ τ2

              K,L,T ▷ C : idx(l,τ1) ⇒ τ2    L ⊢ Ï : idx(l,τ1)
    IAPP      ---------------------------------------------------
              K,L,T ▷ C Ï : τ2

              K,L,T ▷ Ci : τi (1 ≤ i ≤ n)
    RECORD    ----------------------------------------
              K,L,T ▷ {C1,···,Cn} : {l1:τ1,···,ln:τn}

              K,L,T ▷ C1 : τ1    K ⊢ τ1::{{l:τ2}}    L ⊢ Ï : idx(l,τ1)
    INDEX     ------------------------------------------------------------
              K,L,T ▷ C1[Ï] : τ2

              K,L,T ▷ C1 : τ1    K ⊢ τ1::{{l:τ2}}    L ⊢ Ï : idx(l,τ1)    K,L,T ▷ C2 : τ2
    MODIFY    --------------------------------------------------------------------------------
              K,L,T ▷ modify(C1,Ï,C2) : τ1

              K,L,T ▷ C : τ1    K ⊢ τ2::<<l:τ1>>    L ⊢ Ï : idx(l,τ2)
    VARIANT   -----------------------------------------------------------
              K,L,T ▷ <Ï=C> : τ2

              K,L,T ▷ C : <l1:τ1,···,ln:τn>    K,L,T ▷ Ci : τi→τ (1 ≤ i ≤ n)
    SWITCH    -----------------------------------------------------------------
              K,L,T ▷ switch C of C1,···,Cn : τ

              K{t1::k1···tn::kn},L,T ▷ C : τ
    GEN       ----------------------------------- if ti ∉ FTV(L ∪ T) (1 ≤ i ≤ n)
              K,L,T ▷ C : ∀t1::kn···tn::kn.τ

              K,L,T ▷ C1 : σ    K,L,T{x:σ} ▷ C2 : τ
    LET       -----------------------------------------
              K,L,T ▷ let x=C1 in C2 : τ

  図13. 実装の計算のための型付け規則 λlet,[].

  型付け規則の集合は図13に示されています。
  我々は λlet,[] の型推論には関心がないので、我々が λlet,# に使用したものよりも GEN に対してより一般的でより自然な規則を採用します。
  これにより、主題簡約特性の証明がやや容易になります。
  このようなシステムでは、 `K,L,T ▷ C : σ` が導出されれば、 `λlet,[] |- K,L,T ▷ C : σ` と書きます。
  `λlet,[] |- K,L,T ▷ C : σ` ならば `σ` が `K` の下で well formed であることは容易に証明されます。

<!--29 872-->

    (β)       (λx.C1) C2                ⟹ [C2/x]C1
    (index)   {C1,···,Cn}[i]            ⟹ Ci (1 ≤ i ≤ n)
    (modify)  modify({C1,···,Cn},i,C)   ⟹ {C1,···,Ci−1,C,Ci+1,···,Cn} (1 ≤ i ≤ n)
    (switch)  switch <i=C> of C1,···,Cn ⟹ Ci C (1 ≤ i ≤ n)
    (iapp)    (λI.C) Ï                  ⟹ [Ï/I]C
    (let)     let x=C1 in C2            ⟹ [C1/x]C2

  図14. 実装計算 λlet,[] の簡約規則.

  この型システムの、 主題簡約特性を示します。これは、後でコンパイルアルゴリズムが λlet,# の操作上の動作を保持することを確認するのに役立ちます。
  λlet,[] の使用法は λlet,# を実装するための抽象マシンであるので、 λlet,[] 自体の型の健全性のより強い性質は必要ありません。
  λlet,# のコンパイルされた項の操作的意味論に関する λlet,[] の型の健全性は、後で確立するコンパイルの正当性に従います。

  λlet,[] の簡約公理を図14に示します。
  `C1` から `C2` への簡約公理の1つを適用することによって、 `C1` から `C2` が得られた場合、 `C1→C2` と書かれます。
  簡約関係 `C1→→C2` は `→` の再帰的推移閉包として定義されます。
  以下の置換補題は、主題簡約定理を証明するのに有用です。

#### 補題 4.2.1.

  `λlet,[] |- K,L,T {x : σ1} ▷ C1 : σ2` かつ `λlet,[] |- K,L,T ▷ C2 : σ1` ならば `λlet,[] |- K,L,T ▷ [C2/x]C1 : σ2` です。

#### 証明

  証明は、 `C1` の型付け導出の誘導によります。
  興味深いのは変数公理だけです。
  他のケースは補助定理2.2.4に類似しています。

  `K,L,T{x:σ1} ▷ y : τ2` を VAR 公理とします。
  `x /= y` の場合は自明です。
  `x = y` とし、 `σ1 = ∀t1::k1···tn::kn.τ1` とすると、 `K |- ∀t1::k1···tn::kn.τ1 ≥ τ2` となるので、 `dom(S) = {t1,···,tn},(K,S)` は、 `K{t1::k1···tn::kn}` と `S(τ1) = τ2` を尊重します。
  `n = 0` ならば、すなわち、`σ1`が単相ならば、`σ1 = τ2` であり、したがって `λlet,[] |- K,L,T ▷ C2 : τ2` です。
  そうでなければ `K,L,T ▷ C2 : σ1` は GEN によって導出されなければならないので、 `{t1,···,tn}` が `T` または `L` に現れないように `λlet,[] |- K{t1::k1···tn::kn},L,T ▷ C2 : τ1` が導出されなければなりません。
  λlet,# に対して 補題2.2.3 により `λlet,[] |- K,L,T ▷ C2 : τ2` です。 □

#### 補題 4.2.2

  `λlet,[] |- K,L{Ï:idx(l,τ1)},T ▷ C : τ` かつ `L |- Ï : idx(l,τ1)` ならば `λlet,[] |- K,L,T ▷ [Ï/I]C : τ` です。

#### 証明

  これは、 `C` の型付け誘導についての誘導によって証明されます。
  INDEX 規則の場合のみを示します。
  IAPP、MODIFY、VARIANT のケースも同様に表示できます。
  他のすべての事例は誘導仮説から直接得られます。

  `K,L{Ï:idx(l,τ1)},T ▷ C1 : τ2`, `K |- τ2::{{l':τ}}`, `L{Ï:idx(l,τ1)} |- Ï1 : idx(l',τ2)` から INDEX 規則によって、`K,L{Ï:idx(l,τ1)},T ▷ C1[Ï1] : τ` を生成します。
  帰納仮説によって、`λlet,[] |- K,L,T ▷ [Ï/I]C1 : τ2` です。
  考慮すべき2つのケースがあります。
  １つ目のケースは、`Ï1= I` とします。
  それから、`τ1 = τ2` かつ `l = l'` となり、したがって、`K |- τ2::{{l:τ}}` かつ `L |- Ï : idx(l,τ2)` となります。
  型付け規則によって、`λlet,[] |- K,T ▷ ([Ï/I]C1)[Ï] : τ` すなわち `λlet,[] |- K,T ▷ [Ï/I](C1[I]) : τ`　です。
  2つ目のケースは、 `Ï1 /= I` とします。
  これから、 `|idx(l',τ2)|` が定義され、 `Ï1 = |idx(l',τ2)|` または `Ï1 ∈ dom(L)` です。
  いずれの場合も、 `L |- Ï1 : idx(l',τ2)` かつ型付け規則によって、`λlet,[] |- K,T ▷ ([Ï/I]C1)[Ï1] : τ` です。
  しかし、`[Ï/I](C1[Ï1]) = ([Ï/I]C1)[Ï1]` です。 □

<!--30 873-->

#### 定理 4.2.3 `λlet,[] |- K,T,L ▷ C1 : σ` かつ `C1 →→ C2` ならば `λlet,[] |- K,T,L ▷ C2: σ` です。

#### 証明

  単相型の定理を示すことで十分です。
  この証明は、上記の2つの補題を用いて定理2.2.5と同様です。

## 4.3 コンパイルアルゴリズム

  型推論によって得られた型情報を用いて λlet,# のコンパイルアルゴリズムを開発します。
  型推論アルゴリズムは、与えられた λlet,# 項を、コンパイルに必要なすべての型情報を含む明示的に型指定された Λlet,#  に変換しています。
  そこで、 Λlet,# 項を λlet,[] にコンパイルするアルゴリズムとしてコンパイルアルゴリズムを示します。

  はじめに説明したように、多相レコード操作を含む多相関数をコンパイルするための戦略は、適切なインデックス抽象を挿入することです。
  この戦略では、 λlet,# の型 `σ` の多相関数を、 `σ` の kind 型限定子によって示される必要なインデックス抽象を挿入することによって `σ` から得られる型を持つ項にコンパイルします。
  ソースコードの型とコンパイルされたコードの型との間の形式的な関係を確立するために、まず以下の補助的な概念を定義します。

  kind `k` の `t` に含まれるインデックス型の集合 `IdxSet(t::k)` は、以下のように定義されます。

    IdxSet(t::U) = ∅
    IdxSet(t::{{F}}) = {idx(l,t)|l ∈ dom(F)}
    IdxSet(t::<<F>>) = {idx(l,t)|l ∈ dom(F)}

  この定義は、多相型と kind 割り当てに拡張されています:

    IdxSet(∀t1::k1···tn::kn.τ) = IdxSet(t1::k1) ∪···∪ IdxSet(tn::kn)
    IdxSet(K) = ∪{IdxSet(t::k)|(t::k) ∈ K}

  λlet,# で与えられた型 `σ` について、 λlet,[] の対応する型 `(σ)*` は以下のように定義され

    (∀t1::k1···tn::kn.τ)* = ∀t1::k1···tn::kn.idx(l1,t1')⇒···idx(lm,tm')⇒τ

  `idx(l1,t1'),···,idx(lm,tm')` は次のように順序付けられた `IdxSet(t1::k1) ∪···∪ IdxSet(tn::kn)` のインデックス型の集合です: `i < j` または `i = j` かつ `l << l'` ならば、 `idx(l,ti)`は `idx(l',tj)` に先行します。
  特に、任意の単相型 `τ` について、`(τ)* = τ` です。
  以下はその例です。

    (∀t2::{{a:bool,b:int}}.∀t3::{{a:t2}}.t2→t3)* =
      ∀t2::{{a:bool,b:int}}.∀t3::{{a:t2}}.idx(a,t2)⇒idx(b,t2)⇒idx(a,t3)⇒t2→t3

  この定義は、次のように型の割り当てに拡張されます:

    (T)* = {x : (T(x))* |x ∈ dom(T)}

  kind 割り当て `K` に対して、 `K` によって決定されるインデックス割り当て `LK` を `LK = {I : idx(l,t)|idx(l,t) ∈ IdxSet(K),each I fresh}` として定義します。

<!--31 874-->

  コンパイルアルゴリズムは、図15において、 `LK,(T)*` および `M` をとり、実装計算の項を計算するアルゴリズム `C` として与えられます。
  `LK` は任意の対 `(l,t)` に対して多くても1つの `(I,idx(l,t)) ∈ LK` があるという性質を持っているので、 したがって、 `C` は決定論的アルゴリズムです。

  このコンパイルでは、次の定理に示すように型が保持されます。

#### 定理4.3.1

  `Λlet,# |- K,T ▷ M : σ` ならば、 `C(LK,(T)*,M)` は `λlet,[] |- K,LK,(T)* ▷ C : (σ)*` のように `C` で成功します。

#### 証明

  これは、`M` の構造上の誘導によって証明されます。
  ここでは、変数、フィールド選択、および一般化のケースを示します。
  バリアントおよび修正式のケースは、フィールド選択の場合と同様に表示できます。
  他のすべてのケースは、対応する誘導仮説から容易に従います。

  `(x τ1···τn)`: `Λlet,# |- K,T ▷ (x τ1···τn) : τ` とします。 `S = [τ1/t1,···,τn/tn]` とします。
  これより、 `T(x) = ∀t1::k1···∀tn::kn.τ0,K |- S(ti) :: S(ki)` かつ `τ = S(τ0)` です。
  `(T)*`　の定義により、`{idx(l1,t1'),···,idx(lm,tm')} = IdxSet(∀t1::k1···∀tn::kn.τ0)` となるような `(T)* (x) = ∀t1::k1···∀tn::kn.idx(l1,t1')⇒···idx(lm,tm')⇒τ0` です。
  規則 VAR より、 `λlet,[] |- K,LK,(T)* ▷ x : idx(l1,S(t1'))⇒···idx(lm,S(tm'))⇒S(τ0)` です。
  `Ïi` をアルゴリズムで言及したものとします。
  それぞれの `idx(l,S(ti'))` に対して、 `S(ti')` が型変数 `t` ならば `t ∈ dom(K)` で、`LK` の特性によって、`(Ii:idx(l,S(ti'))) ∈ LK` のような `Ii` があり、`Ïi = Ii` です。
  `S(ti')` が型変数でない場合、 `Ïi = |idx(li,S(ti'))|` です。
  したがって、いずれの場合も `LK |- Ïi : idx(l,S(ti'))` です。
  したがって、アルゴリズムは `(x Ï1···Ïm)` かつ `λlet,[] |- K,LK,(T)* ▷ (x Ï1···Ïm) : τ` で成功します。

  `M1 : τ1#l`: `Λlet,# |- K,T ▷ M1 : τ1#l : τ2` とします。
  これより `Λlet,# |- K,T ▷ M1 : τ1` かつ `K |- τ1 :: {{l:τ2}}` です。
  帰納仮説によって、 `C(LK,(T)*,M1) = C1` は `λlet,[] |- K,LK,(T)* ▷ C1 : τ1` です.
  このアルゴリズムで言及されたものを `Ï` とします。
  `τ1` が型変数 `t` ならば、`t ∈ dom(K)` です。
  `K |- t :: {{l:τ2}}` から, `K(t) = {{F}}` で `F` は `l: τ2` を含むため
  `LK` の性質によって、`(I:idx(l,t)) ∈ LK` かつ `Ï = I` のような `I` が存在します。
  `τ1` が型変数でなければ、`|idx(l,τ1)| = i` は整数 `i` かつ `Ï = i` です。
  したがって、どちらの場合も、`LK |- Ï : idx(l,τ1)` です。
  これらのことから、`C(LK,(T)*,M1:τ1#l)` は、`C1[Ï]` かつ `λlet,[] |- K,L K,(T)* ▷ C1[Ï] : τ2` で成功します。

  `Poly(M:σ)`: `Λlet,# |- K,T ▷ Poly(M:σ) : σ` とします。
  これより `Cls(K',T,τ) = (K,∀t1::k1···∀tn::kn.τ)` で `Λlet,# |- K',T ▷ M : τ` である `σ = ∀t1::k1···∀tn::kn.τ` です。
  `∀t1::k1···∀tn::kn.idx(l1,t1')⇒···⇒idx(lm,tm')⇒τ1 = (σ)*` とすると、
  `LK' = LK{I1:idx(l1,t1'),···,Im:idx(lm,tm')} (I1,···,Im fresh)` です.
  帰納仮説によって、 `C(LK',(T)*,M) = C such that λlet,[] |- K',LK',(T)* ▷ C : τ` です.
  これより `C(LK,(T)*,Poly(M:σ))` は `λI1···λIm.C` で成功します。
  規則IABSを `λlet,[] |- K',LK',(T)* ▷ C : τ` に繰り返し適用することにより、我々は `λlet,[] |- K',LK,T ▷ λI1···λIm.C : idx(l1,t1')⇒···idx(lm,tm')⇒τ` を得ます。

  `LK` は `K,ti /∈ FTV(LK ∪ (T)*) (1 ≤ i ≤ n)` の下で well formed であるため
  `λlet,[] |- K,LK,(T)* ▷ C : (∀t1::k1···∀tn::kn.τ)*` です。 □

  この結果を定理3.5.1 と組み合わせると、次のようになります。

#### 結果4.3.2 `WK(K,T,e) = (K',S,M,σ)` ならば、 `λlet,# |- K',S(T) ▷ e : σ` かつ `C(LK',(S(T))*,M)` は `λlet,[] |- K',LK',(S(T))* ▷ C : (σ)*` のように `C` で成功します。

<!--32 875-->

    IdxSet(t::U) = ∅
    IdxSet(t::{{F}}) = {idx(l,t)|l ∈ dom(F)}
    IdxSet(t::<<F>>) = {idx(l,t)|l ∈ dom(F)}

    IdxSet(∀t1::k1···tn::kn.τ) = IdxSet(t1::k1) ∪···∪ IdxSet(tn::kn)
    IdxSet(K) = ∪{IdxSet(t::k)|(t::k) ∈ K}


    C(L,T,(x τ1···τn)) = let (∀t1::k1···tn::kn.idx(l1,t1')⇒···idx(lm,tm')⇒τ) = T(x)
                             S = [τ1/t1,···,τn/tn]
                             Ïi = | i if |idx(l,S(ti'))| = i
                                  | I if |idx(l,S(ti'))| is undefined and (I:idx(l,S(ti'))) ∈ L
                         in (x Ï1···Ïm)
    C(L,T,cb) = cb
    C(L,T,λx:τ.M) = λx.C(L,T{x:τ},M)
    C(L,T,M1 M2) = C(L,T,M1) C(L,T,M2)
    C(L,T,{l1=M1,···,ln=Mn}) = {C(L,T,M1),···,C(L,T,Mn)}
    C(L,T,M:τ#l) = let C = C(L,T,M) and
                       Ï = | i if |idx(l,τ)| = i
                           | I if |idx(l,τ)| is undefined and (I:idx(l,τ)) ∈ L
                   in C[Ï]
    C(L,T,modify(M1:τ,l,M2)) = let C1 = C(L,T,M1),
                                   C2 = C(L,T,M2),and
                                   Ï = | i if |idx(l,τ)| = i
                                       | I if |idx(l,τ)| is undefined and (I:idx(l,τ)) ∈ L
                               in modify(C1,Ï,C2)
    C(L,T,(<l=M>:τ)) = let C = C(L,T,M) and
                           Ï = | i if |idx(l,τ)| = i
                               | I if |idx(l,τ)| is undefined and (I:idx(l,τ)) ∈ L
                       in <Ï=C>
    C(L,T,case M of <l1=M1,···,ln=Mn>) =
      switch C(L,T,M) of C(L,T,M1),···,C(L,T,Mn)
    C(L,T,Poly(M1:∀t1::k1···∀tn::kn.τ1)) =
      let ∀t1::k1···∀tn::kn.idx(l1,ti') ⇒ idx(lm,tm') ⇒ τ1
             = (∀t1::k1···∀tn::kn.τ1)*
          C1 = C(L{I1:idx(l1,t1'),···,In:idx(lm,tm')},T,M1) (I1,···,Im fresh)
      in λI1···λIm.C1
    C(L,T,let x:σ=M1 in M2) = let C1 = C(L,T,M1)
                                  C2 = C(L,T {x:(σ)*},M2)
                              in let x=C1 in C2

  図15. コンパイルアルゴリズム

<!--33 876-->

  上記の結果は、コンパイルアルゴリズムが型 `σ` の項を型 `(σ)*` の項に写像することを示しています。
  `(τ)* = τ` なので、コンパイルはすべての単相型を保持します。

## 4.4 λlet,# 型付けから空の型変数を削除

  上記のアルゴリズムは kind 付き型付き Λlet,# をkind 付き型付き λlet,[] に変換します。
  これを λlet,# のコンパイルアルゴリズムとして使用するには、注意が必要な微妙な点が1つあります。
  それは、一貫性 (coherence) の問題です [Breazu-Tannen et al. 1991]。
  Ohori [1989] に示されているように、 ML の Damas-Milner システムは Core XML に関して一貫性がなく、 λlet,# と Λlet,# との関係にも同じことが当てはまります。
  (関連する議論については Harper and Mitchell [1993] も参照)。

  一貫性の失敗の原因は、型付けにおける結果の型または型の割り当てに現れない型の導出で使用される自由型の変数です。
  これらの型変数はまた、前節で開発したコンパイルアルゴリズムを適用する際に問題を引き起こします。
  これを見るには、 raw の項 `(λx.cb) (λx.(x#l) + 1)` を考えてみましょう。

  型推論アルゴリズムは、以下の型の λlet,＃

    {t::{{l : int}}},∅ ▷ (λx.cb) (λx.(x#l) + 1) : b

  に対して以下の型の Λlet,＃ を生成します:

    {t::{{l : int}}},∅ ▷ (λx:t → int.cb) (λx:t.(x#l) + 1) : b

  kind 付き型変数 `t` は、多相フィールド選択 `x#l` の型検査に導入されますが、型代入または結果型には現れないため、これ以上インスタンス化されることはありません。
  結果として、与えられた閉じた項は、決定されない `l` の位置を示す空きインデックス変数を含む Λlet,# の開いた項に変換されます。

  この問題に対する我々の解は、3章で与えられたミルナー型の推論アルゴリズムを改良して、これらの "冗長(redundant)" 型または空の型変数を削除することです。
  `K,T ▷ e : τ` の型変数 `t` は、`t ∈ dom(K)` かつ `t ∈/ EFTV(K,τ) ∪ EFTV(K,T)` ならば空になります。

  あらかじめ定義された基本型 `b0` があると仮定します。
  `b0` の選択は重要ではありません。
  `K,T ▷ e : τ` を型付けし、　`t`　を　`t　∈/ FTV(K(t))` のような型付けの空の型変数とします。
  そして `K` は `K'{t::k}` と書かれます。
  次のようにして、`K` の `t` の正規化インスタンス `τt` を定義します:

          b0    if k = U
    τt =  {F}   if k = {{F}}
          <F>   if k = <<F>>

  我々は、kind 付き置換 `(K',[τt/t])` を適用することによって、型付けから `t` を削除することができます。
  空型変数の集合が `K` に相互循環依存性を持たない場合、 `1 ≤ i ≤ j ≤ n` ならば、 `ti ∈/ FTV(K(tj))` となるような 列 `t1,···,tn` を持ちます。
  そして、`t1,···,tn` について上記のプロセスを繰り返すことにより、 kind 付き置換のシーケンス `(Ki,[τti/ti])` を得ます。
  我々は、kind 付き置換 `(Kn,[τn/tn] ◦···◦ [τi/t1])` として、 `K,T ▷ e : τ` の正規化インスタンス化を定義します。
  この定義から、以下の結果を容易に証明することができます。

#### 補題 4.4.1

  `(K0,S0)` が型付け `K,T ▷ e : τ` の正規化インスタンス化である場合、 `(K0,S0)` は `K` を尊重します。

<!--34 877-->

  補題2.2.3 では、以下のことが成り立ちます。

#### 系4.4.2

  `λlet,# |- K,T ▷ e : τ` かつ `(K0,S0)` が `K,T ▷ e : τ` の正規化インスタンス化ならば、`λlet,# |- K0,T ▷ e : τ` です。

  これは、空の型変数集合に循環依存性がない場合、その項の型付けの性質に影響を与えることなくそれらを削除できることを示しています。
  我々は `K0,T ▷ e : τ` を `λlet,# |- K,T ▷ e : τ` の正規化インスタンスと呼びます。

  我々は λlet,# のプログラムを、以下の形式の閉じた型として識別します:

    ∅,∅ ▷ e : σ

  前の章で定義された型推論アルゴリズムを改良して、トップレベルの型抽象化の直前に推論された型付けが存在する場合にはそれを正規化インスタンスにします; それ以外の場合は、型エラーが報告されます。
  プログラムは閉じた型付けを有さなければならず、その派生には循環依存性を持つ kind 割り当てが含まれていないため、このプロセスはプログラムの型付け性を変更しません。
  上記の形式のプログラムから、洗練された型推論アルゴリズムは、
  λlet,# の上記形式のプログラムから、洗練された型推論アルゴリズムは、以下の閉じた型付け Λlet,＃ を生成します

    ∅,∅,∅ ▷ Poly(M:σ) : σ

  我々は、これらの閉じた型付けを別々のコンパイルの単位とみなします。

  この改良により、前の節で与えられたコンパイルアルゴリズムは、 λlet,# のコンパイルアルゴリズムとして機能します。
  系4.3.2 は次のようになります。

#### 系4.4.3

  もし `e` が well typed な λlet,# プログラムならば、 `λlet,# |- ∅,∅ ▷ e : σ`、 `Λlet,# |- ∅,∅ ▷ M : σ` および `C(∅,∅,M)` が `λlet,[] |- ∅,∅,∅ ▷ C : (σ)∗` のような `C` で成功する、いくつかの `S,M,σ` について、`WK(∅,∅,e)` が `(∅,S,M,σ)`で成功します。

  コンパイルの例を見てみましょう。
  λlet,# の項 `λx.x#Name` から、型推論プロセスは次のプログラムを生成します

    Λlet,# |- ∅,∅ ▷ Poly(λx:t2.x#Name : ∀t1::U.∀t2::{{Name:t1}}.t2→t1)
                  : ∀t1::U.∀t2::{{Name:t1}}.t2→t1

  このプログラムから、コンパイルアルゴリズムは次の結果を生成します

  C(∅,∅,Poly(λx:t2.x#Name : ∀t1::U.∀t2::{{Name:t1}}.t2→t1)) = λI.λx.x[I]

  これには以下の型付けがあります:

    λlet,[] |- ∅,∅,∅ ▷ λI.λx.x[I] : ∀t1::U.∀t2::{{Name:t1}}.idx(Name,t2) ⇒ t2→t1

  プログラム

    let name=λx.x# Name in (name {Name="Joe",Office=403},
                            name {Name="Hanako",Age=21,Phone=7222})

  は、前の章で見たように Λlet,# で次のプログラムに変換されます:

    E ≡ let name:∀t1::U.∀t2::{{Name:t1}}.t2→t1
              = Poly(λx:t2.x#Name : ∀t1::U.∀t2::{{Name:t1}}.t2→t1)
        in ((name string {Name:string,Office:string})
              {Name="Joe",Office=403},
              (name string {Name:string,Age:int,Phone:int})
              {Name="Hanako",Age=21,Phone=7222})

<!--35 878-->

  コンパイルアルゴリズムは次の結果を生成し

    C(∅,∅,E) = let name=λI.λx.x[I] in (name 1 {"Joe",403},
                                        name 2 {21,"Hanako",7222})

  期待される型付けを有し、`("Joe","Hanako")` と評価されます。

  次は、多相バリアントと空型変数削除を含むプログラムの例です。
  以下の λlet,# のプログラム

    let point = <Cartesian={X=2.0,Y=3.0}> in
      case point of <Cartesian=λc.sqroot(square(c#X) + square(c#Y)),Polar=λp#R>

  は、 Λlet,＃ の次のプログラムに変換されます。

    F ≡ let point:∀t::<<Cartesian:{X:real,Y:real}>>.t
            = Poly((<Cartesian={X=2.0,Y=3.0}>:t)
                    : ∀t::<<Cartesian:{X:real,Y:real}>>.t)
        in case (point <Cartesian:{X:real,Y:real},Polar:{R:b0}>) of
           <Cartesian=λc:{X:real,Y:real}.sqroot(square(c#X)+square(c#Y)),
            Polar=λp:{R:b0}.x#R>

  これから、コンパイルアルゴリズムは次のコードを生成します:

    C(∅,∅,F) = let point=λI.<I={2.0,3.0}>
                 in switch (point 1) of <λc.sqroot(square(c[1]) + square(c[2])),λx.x[1]>

  `case`　文の `Polar` 分岐に対しては、空型変数の削除が正しく実行され、未使用のフィールド拡張 `x#R` は、デフォルトのインデックス値　`1`　でインデックス式にコンパイルされます。

## 4.5 コンパイルの正当性

  4章では、コンパイルアルゴリズムが型付けを保持することを示しました。
  この章では、コンパイルアルゴリズムがプログラムの操作上の動作も保持することを示しています。
  λlet,# の型システムは、その操作的意味論に関しては健全であることを示しているので、操作上の振る舞いを保持することで、 λlet,# の型システムはコンパイルされた λlet,[] 内のコードの操作的意味論に関しても健全です。

  基本型の項に関して、所望の性質は、元の項とコンパイルされた項が同じ定数値に評価されるという単純なものです。
  我々はこれを多相型を含む任意の型に一般化する必要があります。
  我々の戦略は、上記の関係を任意の型に持ち上げる論理的な関係という概念を適用することです。

  `σ` を閉じた型 λlet,# とします。
  `σ` を集合 `{e|λlet,# |- ∅,∅ ▷ e : σ}` とし、 `Termσ` を集合 `{M|λlet,[] |- ∅,∅,∅ ▷ M : (σ)*}` とします。
  我々は、以下のように、 `σ` 上の誘導によって、型インデックス付きの関係の集合 `{Rσ ⊆ termσ × Termσ}` を定義します。

    (e,C) ∈ R σ ⇐⇒ (1) e ↓ iff C ↓ and
                      (2) one of the following conditions holds

  — `σ = b` のとき、 `e ↓ e'` かつ `C ↓ C'` ならば `e' = C'` です。

  - `σ = τ1→τ2` のとき、任意の `e0`、 `C0` に対して、`(e0,C0) ∈ Rτ1`、 `(e e0,C C0) ∈ Rτ2` です。

  - もし `σ = {l1:τ1,···,ln:τn}` のとき、`e ↓ e'` かつ `C ↓ C'` ならば、`1 ≤ i ≤ n` であるすべての`(ei,Ci) ∈ Rτi` で `e' = {l1=e1,···,ln=en}`、 `C' = {C1,···,Cn}` です。

<!--36 879-->

  - `σ = <l1:τ1,···,ln:τn>` のとき、`e ↓ e'` かつ `C ↓ C'` ならば、`e' = <li= e''>`、 `C' = <i=C''>` かつ `(e'',C'') ∈ Rτi` であるような `i` が存在します。

  - `σ = ∀t1::k1.···tn::kn.τ` のとき

    (σ)* = ∀t1::k1.···tn::kn.idx(l1,t1') ⇒···idx(lm,tm')⇒τ

  ならば、 `{t1::k1.···tn::kn}` を満たす任意の基礎置換 `S` に対して、

    (e,(···(C i1)···im)) ∈ R^(S(τ))

  であり、ここで `ij = |S(idx(lj,tj'))| (1≤ j ≤ m)` です。

  ここで、 λlet,# の型健全性定理(定理3.2.1)と λlet,[] の主題定理(定理4.2.3)から、 `e ∈ termσ` かつ `C ∈ Termσ` かつ `e ↓ e'` かつ `C ↓ C'` ならば `e' ∈ termσ` かつ `C' ∈ Termσ` です。
  さらに、 `Rσ` の定義によって、`(e,C)∈ Rσ` ならば `(e',C') ∈ Rσ` です。

  `T` を λlet,# の閉じた型割当てとします。
  λlet,# における `T`-環境は、任意の `x ∈ dom(η1)`、`η1(x) ∈ term^(T(x))` で `dom(η1) = dom(T)` となるような関数 `η1` です。
  λlet,[] における `A(T)*`-環境は、任意の `x∈dom(η2), η2(x) ∈ Term ^((T)* (x))`で、`dom(η2) = dom(T)` となるような関数 `η2` です。
  `L` を well-formed な閉じた型インデックス割り当てとします。
  λlet,[] における `A(T)*`-環境 `η2`は、すべての `I ∈ dom(L)` に対して、その `I` の値を `|L(I)|` とすることによって `dom(T)∪dom(L)`上で定義された関数に一意に拡張されます。 
  我々は、 `η2` の `dom(L)` 拡張について `ηL2` と書きます。

  関係 `R` は環境に拡張されます。
  `RT` は λlet,# の `T`-環境と λlet,[] の `T`-環境との関係であり、任意の `x ∈ dom(T), (η1(x),η2(x)) ∈ R^(T(x))` に対して、 `(η1,η2) ∈ RT` です。

  今、次の定理があり、その証明は付録に引き継がれます。

#### 定理4.5.1

  `Λlet,# |- K,T ▷ M : σ` は任意の型付けとします。
  もし、`C(LK,(T)∗,M) = C` ならば、 `K` を考慮した任意の基礎置換 `S` かつ任意の対の環境`(η1,η2) ∈ R^(S(T)), (η1(erase(M)),η2_{S(LK)} (C)) ∈ R^(S(σ))` です。

  プログラムには、以下の性質があります。

#### 系4.5.2

  `e` が well typed な λlet,# プログラムならば、`C(∅,∅,M)` が `(e,C) ∈ Rσ` のようないくつかの `S` で成功する、いくつかの `S,M,σ` について、`WK(∅,∅,e)` が `(∅,S,M,σ)`で成功します。

  観測可能な型の集合を以下の構文で定義すると

    ω ::= b | {l:ω,···,l:ω} | <l:ω,···,l:ω>

  関係 `Rω` は本質的に同一的(レコードとヴァリアントのモジュロ表現)であるため、 λlet,# とそのコンパイルされた項の観測可能な型のプログラムは、本質的に同じ値に評価されます。

#5. 実装

この記事で紹介した多相型とコンパイル方法を使用して、多相レコード操作で Standard ML を拡張し、 SML# というコンパイラを実装しました。
SML# は New Jersey の Standard ML コンパイラ [Appel and MacQueen 1991] の拡張です。

